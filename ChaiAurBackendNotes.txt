//videoController 
//comments 
//like
//playlist 
//tweet 

Video 2 Deploy Backend Code in Production.
Express is a package that handle's the request part of the the connection between computer and server.

Here we listen to the request using routes /, /login. 
There are various request such as get, put , post , delete.

Creating empty node application:
(1)Initialise node package manager by typing "npm init" inside the terminal 
It creates a file called package.json with necessary information.

(2)Create new file which is main in package.json 
{ main: index.js }

(3)Create a script command for running or executing the file.
{ "scripts": { "start" : "node index.js" }} 

(4)Now we can execute the file using 
npm run start

(5)Now install Express package using "npm i express"

(6)Import express using " import express from "express" " and asign it to a variable.
const app = express()

(7)Deploying the application 
(a)Install package "dotenv" "npm i dotenv"
(b)Create a new file called ".env"
(c)Add your relevant data into it.
PORT=4000 
(d)Inside your application import {configDotenv} from "dotenv" and pass the path inside it.
(e)configDotenv({path: "././env"})
(f)Replace the port with process.env.PORT

For deployment first create a repo on Github and then deploy it.





Video 3 How to Connect Frontend with Backend.
(1)Create two folder called "Backend" "Frontend" //
(2)Initialise node package manage inside the Backend folder by using "npm init" //
(3)Add express package using npm "npm i express" //
(4)Create a file with the same name as your "main:" which is in your package.json.//
(5)Add a start script inside package.json "start": "node FileName.js"//
(6)Add "type": "module" inside package.json for using latest ES6 syntax for importing and exporting files.//
(7)import express and asign it to a variable and create a get route.//
(8)Add port inside .env and while assigning it use process.env.PORT || 3000 this way there will be no issue during production.//
(9)Add a route for passing data. //
While creating a route for API in backend always give "/api/" before the route. //
(9)Frontend 
(10)Inside directory cd to Frontend folder and type "npm create vite@latest .  " dont forget to add " . " so that all the file's are created inside frontend folder and no new directory is created.//
(11)After that type "npm i"//
(12)check script in package.json to run the file.//
(13)install axios for API handling "npm i axios".//
(14)Search how we use axios using promise .then //
(14)CORS POLICY 
üìù CORS & Proxy in Vite ‚Äì Summary
-CORS (Cross-Origin Resource Sharing) is a browser security rule that blocks requests from one origin (like localhost:5173) to another (like localhost:3000) unless allowed.

-When frontend (Vite) tries to fetch data from backend (Express) on a different port, it triggers a CORS error.

-To bypass this in development, Vite lets us use a proxy.

-Vite acts as a middleman ‚Äî when we call /api/... from the frontend, Vite secretly forwards it to http://localhost:3000/api/....

-This avoids CORS because the browser sees it as coming from the same origin.

(15)While creating proxy in vite. Go to vite.config.js file. Search why do we need proxy. 
(16)Inside defineConfig add a new object called server:{}. Inside server create a object called proxy : {}
(17)Pass in proxy : {'/api': 'http://localhost:3000'}


MiddleWare 
When we use app.use() we are basically using a MiddleWare.






Video 4 Data modelling for backend with Moongoose
Data modelling - Defining the structure of the data.
Following can be used for Data modelling
-Moon modeler //paid  
-Eraser.io 

(1)Before building any kind of project always know what kind of data points will be needed for the data.

(2)Install mongoose using "npm i mongoose" inside -stackblitz //
-mongoose is a library that helps you interact with mongoDb database

(3)Create a new folder called models. Inside the same folder create a new folder called todos.//

(4)Inside todos create a file called "user.models.js" always use .models.js while creating files in this folder. It basically means it denotes model.//

(5)Also do the same for todos and sub_todos//

(6)import mongoose from "mongoose"//

(7)Use "new" while creating schema in mongoose.
new mongoose.Schema()//

(8)This function takes an object.//
const userSchema = new mongoose.Schema({})//

(9)Then export const User = mongoose.model() //this takes two parameter (name of the model, on basis of whose schema should i make the model)//

(10)export const User = mongoose.model("User", userSchema)//

(11)In mongoDB "User" get's converted into LowerCase and plural form. "User" = users //

(12)Inside mongoose.Schema({ 
    username:{
                type:String, 
                required:true, //this field is always required  
                unique:true,   //it should be unique 
                lowercase:true,
            },
    password:{
        type:String,
        require:[true, "password is required"] //we can pass custom messages by passing them inside an array.
    } 
        }
    ) 
(13)We can pass timestamps to add createdAt and updatedAt 

(14)Pass them inside mongoose.Schema({}, {timestamps:true}) //its timestamp's not timestamp 

(15)new mongoose.Schema({
    complete:{
        type:Boolean,
        default:false
    }
})//

(16)Creating relation's between two schemas.
We need two things type and reference. 
new mongoose.Schema({
    createdBy:{
        type: mongoose.Schema.Types.ObjectId, //this tells mongoose that we are going to give them some kind of reference.
        ref: "User", //the name that we give when creating model should be passed here always.
    }
})

(17)We can add array of sub_todos
new mongoose.Schema({
    sub_todos:[{
        type:mongoose.Schema.Types.ObjectId,
        ref:"SubTodo",
    }]
})//

(18)Create schema for sub_todos that includes content, complete, createdBy.//








Video 5 E-commerce or Hospital Data modelling.
(1)Create a new folder for e-commerce.
(2)Create schema for user, categories , product.
(3)Before creating schemas think what field's are dependent on each other. 
(4)Buffer - images , pdf.
(5)user = name, email , password , categories = name , product = name, price, stock, description , category, owner, productImage.
(6)Creating miniModels.
orderItemSchema
{
    productId:{
        type:mongoose.Schema.Types.ObjectId,
        ref:"Product",
    },
    quantity:{
        type:Number,
        required:true,
    }
}

orders 
{
    orderItems:{
        type:[orderItemSchema]
    }
}
(7)Adding choices or enumerations (enum)
{
    status:{
        type:String,
        enum:["PENDING", "CANCELLED", "DELIVERED"],
        default: "PENDING",
    }
}
(8)Hospital









Video 6 How to setup Professional Backend Project.
(1)create a new folder and add package.json file inside it.//
(2)Create a Readme.md //
(3)Push files inside github 
(a)git init 
(b)git add . 
(c)git commit -m "start add intial files"
(d)git branch -M main 
(e)copy rest of the two codes from github "make sure you have set it as upstream"
(f)when we add new files repeat steps b,c and type "git push"
-we can only use git push because we have setup upstream.

(1)create a new folder public and inside this folder create a folder called "temp".//

(2)create a empty file .gitkeep inside "temp" //
-this way we can keep track of empty folders inside github. If we don't add ".gitkeep" github will not track empty folders.

(3)create a file called ".gitignore" inside root or outside of "public"//  
-you can add file names by copying them from .gitignore generators for your use.

(4)create a file called .env //

(5)create a new file inside root ie outside of public . File name should be "src" //

(6)create the following files inside "src"//
-app.js 
-constants.js 
-index.js 

(7)install nodemon using "npm i -D nodemon"//
-the reason we are using -D "dev dependency" is because we only want this package or dependency in our development not in production. 

(8)Inside package.json add a script {"dev" : nodemon src/index.js}//
-here we are telling to reload file index.js when we run "npm run dev"

(9)create the following folders inside src //
-controllers (for functionality)
-db (connection logic)
-middlewares (acts between request and server.)
-models (db models)
-routes (server routes)
-utils (utilities)

(10)install package "npm i -D prettier"

(11)create a new file inside root called ".prettierrc"
-it keeps all the configuration of prettier 
-inside the above file create an object 
{
    "singleQuote":false, //we will only have double quotes inside our files 
    "bracketSpacing":true, //there will be spacing ( ) when we create a bracket 
    "tabWidth":2,
    "semi":true, 
    "trailingComma":"es5",
}

(12)create a new file called ".prettierignore"
-this will tell the files where we have to ignore .prettier 
-add the following inside the file 
*.env 
 .env 
 .env.*

/.vscode
/node_modules 
./dist 









Video 7 How to Connect Db in MERN with Debugging.
-different ways to connect db 
-problems or issued faced during it 

(1)go to mongoDB atlas 
-it is a subservice of mongoDB where they give online service of mongoDB

(2)sign in and create a new project called youtube //

(3)click on "create a deployment"//
-add authentication to access db 
-allow ip address to access db 

(4)select local environment and inside select ip list add 
-0.0.0.0/0 
-click on add entry 

(5)Inside security go to network access 
 -db access 
    -select "read and write any db" for built in role

(6)Go to database 
 - select connect 
 - select compass 
 - copy URL 
//mongodb+srv://govindarsharma26:Govinda@26@cluster0.ghtzkvw.mongodb.net/


(7)Go to .env and add the below items //
-PORT=3000
-MONGODB_URI=//paste the url from step 6 and add the password , remove ending slash  

(8)Go to constants.js and add db name //
-export const DB_NAME = "videotube"

(9)"npm i mongoose express dotenv"

(10)When dealing with db always use try and catch and async await 

(11)import mongoose from mongoose 

(A)First approach

(1)create a async ife function and inside add a try and catch block 
-inside try block - mongoose.connect('url/dbName')

(2)Add a listener after the above 
-app.on("error", () => {
    console.log("error",err);
    throw err   
    })

(3)Search what throw means 

(4)after app.on create an app.listen 
-app.listen(process.env.port, () => {
    console.log("App is running on port: ", process.env.port)
})

(B)Second approach 
In this approach we write the function to call db in other file and export it and then call it inside our index file.

(1)Create a new file inside db folder //
-name it anything eg db.js 

(2)Import the following inside db.js
-import mongoose from mongoose 
-import dbName from constants 


(3)create an async function //

(4)Inside try and catch block write the following// 
-
try{
    const connectionInstance = await mongoose.connect('url/dbname');
    console.log(connectionInstance.connection.host)    //add this to check that you are connected to right server (production,development,..) 
}catch(error){
    console.log(error);
    process.exit(1)     //search what is the meaning of this 
}

(6)export default the above function //

(7)inside index.js file //
-import dotenv from "dotenv" 
-dotenv.config({path:"environment variable path"})

(8)inside package.json inside dev script add the following 
-"dev": "nodemon -r dotenv/config--experimental-json-modules src/index.js"

(9)call the function 

(10)Anytime you make any changes into environment variable you have to restart your server.

Assignment 
-check what is inside connectionInstance object 







Video 8 Custom API response and error handling 
(1)Inside app.js import express from "express"//

(2)asign express() to a variable app and export it //
const app = express()
export {app} 

(3)inside index.js add .then and .catch on connectDb()
connectDb()
.then(() => app.listen(process.env.PORT, () => console.log(`SERVER RUNNING ON PORT: ${process.env.PORT}`)));
.catch((error) => console.log("Mongo db connection failed: ", error));

(4)Whenever we want to run a MiddleWare we use app.use()

(5)Install the following packages//
-npm i cookie-parser cors 

(6)Import the above packages inside app.js// 
import cookieParser from "cookie-parser"
import cors from "cors"

(7)Initialise cors and give it a origin by mentioning it in .env //
app.use(cors({
    origin:process.env.CORS_ORIGIN //in .env for now do CORS_ORIGIN=* this is because when we deploy we will add origin from vercel 
    credentials:true
}))

(8)allow server to recieve json by adding express.json() as a MiddleWare //
-app.use(express.json({limit: "16kb"}))

(9)allow server to access data from url // 
-app.use(express.urlencoded({extended:true, limit:"16kb"}))

(10)allow server to store images and pdfs etc // 
-app.use(express.static("public")) //here public is the folder name that we have created before 

(11)allow server to perform CRUD on cookies stored on users browser //
-app.use(cookieParser())

(12)Creating utility for handling async await and try catch 
(A)inside utility folder create a new file called "asyncHandler.js"
(B)Creata a function called asyncHandler and export it 
(C)inside asyncHandler 
const asyncHandler = (requestHandler) => {
    return (req,res,next) => {
        Promise.resolve(requestHandler(req,res,next)).catch((err)=>next(err))
    }
}

We can also the above using try and catch 
const asyncHandler = (func) => async (req,res,next) => {
    try{
        await func(req,res,next)
    }catch(error){
        res.status(error.code || 500).json({
            sucess: false,
            message: error.message
        })
    }
}

(13)Creating a API error handling.
(A)Create a new file inside utils called ApiError.js 
(B)Create a new class which extends Error
-class ApiError extends Error{}
(C)Inside the constructor of the class write the following 
constructor(
    statusCode,
    message="Something went wrong",
    errors = [],
    stack = "", 
){
    super(message)
    this.statusCode = statusCode
    this.data = null
    this.message = message 
    this.success = false,
    this.errors = errors 

    if(stack){
        this.stack = stack
    }else {
        Error.captureStackTrace(this, this.constructor)
    }
}
(D)export the above class //

(14)Creating an API response program //
(A)Create a new file inside utils called ApiResponse.js 
(B)Create a new class 
-class ApiResponse 
(C)Inside the constructor of the class write the following 
constructor(
    statusCode,
    data,
    message = "Success",
){
    this.statusCode = statusCode
    this.data = data
    this.message = message 
    this.success = statusCode < 400
}
(D)export the above class// 









Video 9 User and video Model with hooks and JWT 
(1)Create the following files inside the models folder //
user.model.js 
video.model.js 
(2)Create user schema using reference from model link from chai aur code github page 

userSchema //
(A)Search what is trim = true and pass it into username   //trim is used to remove whitespace
(B)Pass index = true 
-this is used to make it more searchable inside the db 
-donot make every field have index = true this takes a huge toll on performance
(C)Give custom message on every required = true field //
(D)Add timestamps //

videoSchema //
-Most of it is just two fields 

(3)Install the following aggregration package //
npm i mongoose-aggregate-paginate-v2

(4)Import the above package inside video.model.js //
import mongooseAggregatePaginate from "mongoose-aggregate-paginate-v2"

(5)Add the below line before export Video //
-plugins are basically type of middleWare that tells mongoose to do something before performing any operation on the db 
videoSchema.plugin(mongooseAggregatePaginate) 

(6)Install the following packages //
npm i bcrypt jsonwebtoken 

(7)Import the above packages inside user.model.js //
import jwt from "jsonwebtoken"
import bcrypt from "bcrypt"

(8)Search what are pre hooks in mongoose //
Pre hooks are like middleWare functions executed before a specific operation on a Mongoose document or query. 

(9)Add .pre() on videoSchema just before export Video 
videoSchema.pre()
-it takes two parameters event and cb 
-type of event - (save, validate, remove, updateOne, deleteOne)
-for now we will take save 
-do not write () => inside the cb because it does not have this therefore we use function ()
-search what is "this"
-cb function will be asyn and because it is a middleware it will require next paramter in cb 
-after our work is done we will call this paramter to pass the flag 

(10)userSchema.pre("save", function(){ //
    
})

(11)select password field using this and encrypt it //
userSchema.pre("save", function(){
  this.password = bcrypt.hash(this.password, 10) //it takes two paramater 1-what you want to encrypt 2-how many salt rounds
  next()   
})

(12)Inorder to not encrypt our password on every save we will use this.isModified() it takes field name as parameter //
-if (!this.isModified("password")) //it is passed in string 

(13)//
-if this field is not modified then return next()

(14)Creating custom events //
-userSchema has a object called method 
userSchema.method.methodName 

userSchema.methods.isPasswordCorrect = async function (password) {return await bcrypt.compare(password, this.password)}

-here .compare returns boolean (true or false)

(15)JWT 
(A)JWT is a bearer token 
-Bearer = Whoever has this token will have the data 
(B)Add the following items inside .env 
ACCESS_TOKEN_SECRET=take a string and encrypt it with SHA256 //govinda
ACCESS_TOKEN_EXPIRY=1d (1 day)
REFRESH_TOKEN_SECRET=same as secret generate one with sha256 or any other algorithm //sharma 
REFRESH_TOKEN_EXPIRY=10d 
(C)Add .methods for the above 
-userSchema.methods.generateAccessToken = function () {
    return jwt.sign(    //it takes payload 
        {
            _id: this._id, //this is id from mongodb 
            email: this.email,
            username: this.username,
            fullName : this.fullName
            //payloadName : from where it will be accessed inside db 
        }, 
        process.env.ACCESS_TOKEN_SECRET,
        {
            expiresIn: process.env.ACCESS_TOKEN_EXPIRY 
        }
    ) 
}
(D)
--userSchema.methods.generateRefreshToken = function () {
    //same as generateAccessToken just change the value name from env
    it will only need id 
}










Video 10 How to upload file in Backend using Multer 
When we need to upload file we have two  package's 
1-express fileupload 
2-Multer 

We will use Multer 

Workflow of file uploading 
Upload file using multer --> store it on local device  --> upload it on cloudinary

(1)Sign up on Cloudinary // 

(2)install the following package's  //
-npm i cloudinary 
-npm i multer

(3)Copy "Set up environment code" from cloudinary 

(4)Create a file called "cloudinary.js" inside utils //

(5)Import the following package's in the above file //
-import {v2 as cloudinary} from "cloudinary"
-import fs from "fs"

(6)Paste the configuration copied from step 3 and paste it. Keep necessary info in .env //

(7)Create an async function called uploadOnCloudinary which takes in a paramater called localFilePath //
(A)Inside create a try catch block 
(B)inside try write a condition which will return null if localFilePath is not correct 
-if(!localFilePath) return null 
(C)Now inorder to upload file on cloudinary create a variable called response 
//upload file on cloudinary
const response = await cloudinary.uploader.upload(localFilePath, {resource_type: "auto"}) 
(D)After the file has been uploaded successfully console log it and return it 
//file has been uploaded successfully 
console.log("File has been uploaded Successfully", response.url)
return response 
(E)Inside the catch block do the following 
-Inorder to remove file which is corrupted or malicious we will use fs.unlinkSync  
-fs.unlinkSync(localFilePath) 
-it basically removes the locally saved file as the upload operation got failed 
-return null 
(F)Export the above function 
export {uploadOnCloudinary}

(8)Create a new file inside middleware called "multer.middleware.js" and import it inside it //
-import multer from "multer"

(9)Copy code from DiskStorage section which is in multer github documentation //

(10)Paste the above code inside "multer.middleware.js" and do the following changes //
-Inside destination cb give the following file path 
cb(null, "./public/temp") 

-Inside filename add only the following 
-cb(null, file.originalname)

(11)Export the above 
-export const upload = multer({storage})







Video 11 HTTP Crash Course 

Difference between HTTP and HTTPS 
-When data is sent to HTTP for eg abc it will receive as "abc" 
-When data is sent to HTTPS eg abc it will recieve {key: encrypted form of the data using XOR} 
-It's functionality is same 

Hyper Text Transfer Protocol 
It basically deals with the tranfer of text 

(A)HTTP Headers
-They are metaData //key value sent along with request and response 
-They are used in 
caching , authentication, manage user state - guest , admin 
-Different type's of Header's 
Request Headers - Sent from Client 
Response Headers - Sent from Server 
Representation Headers - encoding / compression deals with zip files 
Payload Data - data sent eg: name:"Govinda", gender:"Male" 

Most common Header's 
User agent - tell's from which browser request came (postman, safari, chrome)
Authorization 
Content type - image, pdf , video 
Cookies 
Cache Control 

(B)HTTP Methods
GET - retrieve a resource 
HEAD - 
OPTIONS - what operations are available 
TRACE - 
DELETE - remove a resource 
PUT - replace a resource 
POST - interact with a resource (mostly add)
PATCH - change part of resource 

(C)HTTP Status Code 
1xx - Informational ()
2xx - Success (Data you have sent has been received or your operation is completed)
3xx - Redirection (Resource has been moved or removed, url has been removed or moved)
4xx - Client Error (Client entered incorrect password, or token not sent, image resolution not correct)
5xx - Server Error (Network broke, traffic in network)

400-Username or email is required 







From this section we start writing actual code for functionality of our app 


Video 12 Complete guide for router and controller with debugging 
(1)Create a file called "user.controller.js" inside controller file and import asyncHandler //

(2)Create a variable called registerUser and assign it the above function //

(3)Inside the above function pass in the below paramter // 
async (req, res) => {
    res.status(200).json({message:"ok"})
}

(4)Export the above // 
-export {registerUser}

(5)Create a new file "user.routes.js" inside routes folder and import the following 
-import {Router} from "express"

(6)Assign Router() to a variable called router and export it 
-const router = Router()
-export default router 

(7)Inside app.js add a comment called //routes import and import the following 
-import userRouter from "./routes/user.route.js" //we can give any name we want when we exporting using "default"

(8)Write a new comment called //routes declaration and do the following 
-Now because we have separated everything we will use middlewares instead of app.get 
app.use("/users", userRouter)

-http://localhost:8000/users/ (preffix)
-whenever user type's "/users" you will give control to userRouter (it will basically go to userRouter file)
-in userRouter file now it will be routed to some other file

(9)go to user.routes.js and add the following before export 
router.route("/register").post(registerUser)

-after comming to the above file we add the above to the preffix 
-http://localhost:8000/users/register 

eg-http://localhost:8000/users/login 


complete sequence of the above 
(1)user goes to /api/v1/users 
(2)this will activate userRouter
(3)inside userRouter "/register" will be added which will call the "registerUser" method 











Video 13 Logic Building / Register Controller 
Before going through the below steps understand the code in the following file's and also code it to understand 
1-index.js //
2-asyncHandler //
3-ApiError //

Following are the steps to register a user in mongoDB

(1)get user details from frontend (postman) in our case 
-inside user.controller.js inside registerUser write the following 
-inorder to take data we will use req.body and asign it to a variable and destructure it 
const {fullName, username, email, password} = req.body;
-open postman and go to the above route and send data by going to body -> raw -> selecting json //  

(2)validation - check if user has provided correct information ie not empty required field's 
-import ApiError inside the above file 
Option 1 
-if(fullName === ""){
    throw new ApiError(400, "fullname is required")
}

Option 2
-search what .some and trim() does by writing it   
if([fullName, email, username, password].some((field) => field?.trim() === "")){
    throw new ApiError(400, "all fields are compulsary or required")
}

//image upload middleware //
-import {upload} from "../middlewares/multer.middleware.js" inside user.routes.js 

(1)We will use middleware before registerUser so that before executing the controller we wil run the following 
-inside router.route write the below code 
post(upload.fields([  //upload gives many options but for now we will use .fields . Fields only take "[]"
]), registerUser)

(2)For adding fields we can mention name and maxCount inside an object 

.post(
  upload.fields([
    {
      name: "avatar",
      maxCount: 1,
    },
    {
      name: "coverImage",
      maxCount: 1,
    },
  ]),
  registerUser
);

(3)check if user already exists: using username, email //
-import User from models inside user.controller.js 

-User.findOne({ $or:[{ email }, { username }] }) 
//.findOne - returns the first user that it finds in the db 
//we can use $ to add condition such as and , or 
//inside $or pass in an object inside the array 
$or: [{}]

-asign the above to a variable and add a condition that if it not exists then return an ApiError

(4)check for images, check for avatar which is a required field // 
Because of middleware req. gets more fields 
-inside the above file 
-req.files?.fileName[0]?.path //in our case it is avatar

-store the reference of above inside const avatarLocalPath 
-do the same for coverImage
-add ApiError if avatarLocalPath is not found 

(5)upload them to cloudinary, avatar //
-import uploadOnCloudinary inside the above file 
-pass above path inside uploadOnCloudinary give it a reference and use await 
-do the same for coverImage
-add ApiError for if avatar reference is not available

(6)create user object - create entry in db //
-We will be using User which has a method called create which takes in a object 
-User.create({
    fullName,
    avatar: avatar.url,
    coverImage: coverImage?.url || "",
    email: email,
    password,
    username: username.toLowerCase()
})
-save it inside an reference of user and use await 

(7)remove password and refresh token field from response 
refer step 8 

(8)check for user creation 
-you can use User.findById(user._id) and add reference and await  
-.select("") we pass in a string and inside this string we mention what we don't need 
-we are doing the above so that frontend only gets the necessary data 
User.findById(user._id).select("-password -refreshToken")
-add api error for the above 

(9)return res 
-import ApiResponse into the above file 
-write the below code 
return res.status(201).json(new ApiResponse(200, createdUser, "User Registered Successfully"))






Video 14 How to use Postman for Backend 

(1)Send all the data inside using form-data //
-Make sure you are passing the field name as it is in the db. 
for eg : fullName should be passed as fullName 

(2)For adding avatar or coverImage use the drop down inside the key field and select "file" //

(3)Unlink files after uploading them on cloudinary. 
-inside cloudinary.js add the following before return response and remove the console.log above it.
fs.unlinkSync(localFilePath)

(4)Console log the following things //
req.files 
all the necessary stuff inside user.controller.js 

(5)Search what Array.isArray() is and add it inside JavaScript.txt notes.

(6)Create a new collection inside postman.//
-create a new folder called user and add the above request 

(7)Inside Environments create a new variable //
-give it a name "server"
-paste the url upto /v1 as the initialValue and currentValue
-select environment and the add the collection name inside it 
-now henceforth before calling use {{server}}/user/register while sending a request 





Video 15 Access Refresh Token , MiddleWare and Cookies in Backend 

Difference between Refresh Token and Access Token

-Access Token are short lived 
user validated using access token 

-Refresh Token are Long lived 
Saved in db and with user 

Todos 
(A)Using req.body get user data
(1)Inside user.controller.js create a function called loginUser and wrap it inside asyncHandler. Export it.//
-get username , password and email from req.body

(B)Give access on the basis of username or password //
-add a if condition if either username or email is not give then throw error that it is required to pass them

(C)Find the user//
(2)Send a query inside the db using "User" (which is a mongodb object) checking if a user with the same username or email exists using "$or" and store the result inside variable "user". Send an error 404 if user does not exist.

(D)Password Check//
(3)Using the newly created instance do the following.
-use isPasswordCorrect method to check if password is correct or not and store it inside a new variable called isPasswordValid.
-the new variable or reference will hold value of boolean  
-Send error if password is incorrect.

(E)Generate Access and Refresh Token 
(4)Create a new async method called generateAccessAndRefreshToken which takes in userId 
(5)Add a try catch block inside it. 
(6)Inside try 
-find the user by using "findById". Pass in userId and store the result in "user" variable //
-add .generateAccessToken() and generateRefreshToken() on user instance and store them in variable called accessToken and refreshToken //

-add the new refreshToken inside db using //
We can save a property inside mongo by just doing 
-instance.property = value 
user.refreshToken = refreshToken 

Then save the changes using the below //
-save the changes in db using .save method and passing validateBeforeSave set as false . Use await but dont create instance 

-return {accessToken, refreshToken}//

(7)Inside catch(error)//
-send a new ApiError saying "Something went wrong while generating access and refresh token"

(8)Inside loginUser call the above created function and pass in userId using user instance also add await and save the result by destructing it//
const {accessToken, refreshToken} 

(9)Create a new instance of "User" called loggedInUser by using the following 
-findById
-.select("-password -refreshToken") //deselects all the not wanted 

(F)Send cookie 
(9)While sending a cookie we have to design an object called options//
 
const options = {
    httpOnly: true,
    secure: true
}

the above is done so that no one can modify cookies from the frontend and can only customise them from the server side 

(10)return the following from loginUser function //
-return res.status(200).cookie()

-it takes the following paramater key and value 
key - "accessToken", 
value - accessToken,
options 

do the same for refreshToken using .cookie method 
.cookie("accessToken", accessToken, options)

-send a json response using 
.json(new ApiResponse(200, {
    user: loggedInUser, accessToken, refreshToken
},"User logged in successfully"))

add . for every new method while returning 

(11)User logout 
-Inorder to logout a user we will have to first clear the cookies 
-Reset refreshToken

-Create a new function inside asyncHandler and store it in "logoutUser" 
-export it 

(12)Creating new auth middleware 
-create a new file called "auth.middleware.js"
-This middleware will verify if user exists or not by adding a new req.user method 

-create a refrence called verifyJWT and wrap it with asyncHandler and also export it using named export 

-inside the asyncHandler also add next along with req, res
next is added because it is a middleWare

-get token access //
-Get access to cookies using req.cookies.cookieName which we specified step 10 as key 
req.cookies?.accessToken
 
-if user is sending custom header then we need to write it like this //
const token = req.cookies?.accessToken || req.header("Authorization")?.replace("Bearer ", "") 

-add an api error if the above is not available by sending the following code 
401, "Unauthorized request"

-import jwt from "jsonwebtoken"

-Inorder to verify the token we will use jwt.token() and store its reference inside "decodedToken" 
jwt.verify() takes the following paramters 
-token- pass in the same token generated above 
-secret- select it from the .env file for accessToken 

-import {User} from "user.model" //select correct path//
-find user from db by using findById(decodedToken._id) and passing "_id" which we created before in user.model.js
-remove password and refreshToken from the field 
-add await and store refrence in variable called "user"
-add ApiError for the above if it does not exist - 401 , "Invalid Access Token"

-req.user = user 
-next()

-add all of the above inside try catch 
-inside catch add ApiError - 401, error?.message || "Invalid Access Token"

(13)Inside user.routes.js 

-add a new route 
router.route("/login").post(loginUser)

-add a comment //secured routes 
router.route("/logout").post(verifyJWT, logoutUser)
//first middleware will run then logoutUser will run

(14)Inside logoutUser 
-using findByIdAndUpdate pass in the following 
await User.findByIdAndUpdate(
    req.user._id,
    {
      $set: { refreshToken: undefined },
    },
    { new: true } //will return new updated value
  );

Because we are talking with db use await 

-copy paste options from the above steps 
-return res.status(200).clearCookie("accessToken", options) // do the same for refreshToken 
.json(new ApiResponse(200, {}, "User logged out"))





üìå Video 16
Access Token and Refresh Token in Backend 

(A)Here we will get Refresh Token from user and check it with our backend if it is valid or not.
(B)The frontend guy will create a endpoint which will be served to user in case accessToken expires. This endpoint will give new refreshToken which we can then compare with the one in our db.

Steps 
(1)Create controller for endpoint //
create a new reference called "refreshAccessToken" by asyncHandler inside user.controller.js
-export it  

(2)Inside the asyncHandler //
-access refreshToken from cookies which the user has and store it inside "incomingRefreshToken". Also give 401 "Unauthorized Request" if not found.
req.cookies.refreshToken || req.body.refreshToken //second one is used when user is sending request via mobile 

(3)Verfying the above token with the one in our db 
-import jwt from "jsonwebtoken" //inside the above file 
-use jwt.verify()

(4)Using the above get user from db.
-give 401, "Invalid Refresh Token" if user not found 

(5)if cookie retrieved from user does not match with the one in db throw the following error 
-401, Refresh Token is expired or used 

(6)copy options from the above and paste it 

(7)use generateAccessAndRefreshToken function to create new token 
-save refreshToken as newRefreshToken

(8)in response send the following  
-status 200 
-both the tokens using cookie()
-.json

(9)keep everything from step 3 till the last step inside try catch 
-catch
401, error?.message || "Invalid Refresh Token" 

(10)create new route for the above 
/refresh-token









üìå Video 17
Writing update controller 

Logic:-


Steps:-
(1)Create a new model called subscription.model.js  //
Only add type and ref for now along with timestamps.
-All add comments 

(2)controller for changing current password //

-take oldPassword , newPassword from user 

-because the user need's to be logged in to change the password get the details about user from middleWare

-find user using userid 

-check if old password received from user is correct with the one received from above 
throw error isPasswordCorrect 400, "Invalid Old Password"
also use await 

-set new password as the user.password 
also save it using .save also add validateBeforeSave:false
no need for reference 

-return status(200) json(200, {}, "Password changed Successfully")

(3)create controller for updateAccountDetails //
-if you want to update any files then it is always recommended to create another controller 

-get fullName and email and send error if not available (400, "All fields are required")

-using findByIdAndUpdate() update both of the above values 
it takes three arguments 
-user id 
-{
    //here we have to use different mongoDb operators 
    $set:{}
} 
-{new: true} //after updating it returns the new value 
-don't include the password field while creating reference for the above.

-send the above reference as json "Account details updated successfully"

(4)Updating files 
-create a new controller called updateUserAvatar 

-get new image path from req.file (we are only using "file" because we don't need "files", same will be done when we add middleware only use "upload.field")
save it in ref avatarLocalPath 
400, "Avatar file is missing"

-uplaod on cloudinary 
400, "Error while uploading on avatar"

-using findByIdAndUpdate update the above 
avatar: avatar.url  
deselect -password 

-return the above reference 
200, "Avatar image updated successfully"

-export the above 

//todo: 
create utility function to delete old avatar image 
-by taking old local avatar path on cloudinary create a utility function to delete it from cloud 

-do the same for coverImage 






üìå Video 18
Understand Subscription Schema 

whenever channel gets subscribed a new document is created 

-Inorder to get all the subscribers of a particular channel we will do the following 
select all the documents which have the channel name we want  









üìå Video 19
üß† Quick mental model

1Ô∏è‚É£ req.params ‚Üí comes from :placeholders in the URL path.

2Ô∏è‚É£ req.query ‚Üí comes from ?key=value query strings.

3Ô∏è‚É£ req.body ‚Üí comes from JSON/form data in the request body.

üìò SQL Joins
Joins help us combine data from two or more tables using a related column (like id, user_id, etc).

Mongo Db Aggregration Pipeline 

-Aggregration pipeline consists of one or more stages.
-Each stage performs an operation on the input doucments. 
 
.aggregate(
    [
        //every object is a stage 
        //stage 1
        {
            //filters documents based on a specific query. Matched documents are passed to next pipeline stage.
            $match:{
                fieldName: value;
            },
            //performs left outer join to a collection 
            $lookup: {
                from: "from where you want join",
                localField: "field at local or primary table",
                foreignField: "field at foriegn table", 
                as: "result" //will return an array   
            }
        },
        //stage 2 
        {
            //adds new fields and we can also compute them 
            $addFields:{
                fieldName: {
                    //method 1 
                    //this will get the result array from the above stage and give the first element
                    $first: "$result",

                    //method 2 
                    //this will give array element based on the number [" ", element_position] 
                    $arrayElemAt: ["$result", 0] 
                }
            }
        },
        //stage 3 
        {
             {
                //gives all the mentioned fields in the final document 
                $project: {
                    "title": 1,
                    
                    // "author_fields.name": 1,
                    // "author_fields.birth_year": 1,
                           
                    //flattened at root
                    name:"$author_fields.name",
                    birth_year:"$author_fields.birth_year"
                },
            },
        }
    ]
)

(1)Create a new controller called getUserChannelProfile

(2)using params get username and add error check if it not exists 
400, username is missing 
also use username?.trim()

(3)save it in reference called "channel" 
User.aggregate([{
    $match: {
        username: username?.toLowerCase()
    },
    {
        $lookup: {
            from: "subscriptions",
            localField: "_id",
            foreignField: "channel",
            as: "subscribers"
        }
    },
    {
        //do the same for subscribedTo,
    },
    {
        $addFields: 
        {
            subscribersCount:
                {
                    $size: "$subscribers"
                },
            channelsSubscribedToCount: 
                {
                    $size: "$subscribedTo"
                },
            isSubscribed:
                {
                    $cond:
                        {
                            if: {$in: [req.user?._id, "$subscribers.subscriber"]},
                            then: true,
                            else: false 
                        }
                }
        }
    },
    {
        //will only give specific values eg value want to pass : 1 
        $project: {
            fullName: 1,
            Username: 1,
            subscribersCount: 1, 
            channelsSubscribedToCount: 1,
            isSubscribed: 1,
            avatar: 1,
            coverImage: 1,
            email: 1,
        }
    }
    }
])

(4)Add error is channel there is nothing inside channel array 
!channel?.length
404, "channel does not exist"

return res
.status(200)
.json(
    new ApiResponse(200, channel[0], "User Channel fetched Successfully")
)





üìå Video 20
Sub pipelines and routes 
 
(1)Create a controller called "getWatchHistory"

(2)create a reference called user for User.aggregate

(3)Get logged in user by doing the following:-
Create a mongoose id using 
$match: { new mongoose.Types.ObjectId(pass in the id) } 
 
(4)write a lookup for getting "watchHistory" 

(5)below the above lookup add another and save it as "owner":-
pipeline: [
    {
        $lookup  
    }
]

(6)Add another pipeline for the above 
pipeline: [
    {
        $lookup:{
            ...,
            pipeline: [
                {
                    $project:{
                        //all the data mentioned here will be saved in owner 
                        fullName:1,
                        username:1,
                        avatar:1
                    }
                },
                {
                    $addFields:{
                        //overwriting existing field 
                        owner:{
                            $first: "$owner"
                        }
                    }
                }
            ]
        }  
    }
]

(7)return res.status(200).json(new ApiResponse(200, user[0].watchHistory, "Watch History Fetched successfully" ))

(8)change route for 
userAvatar 
upload.single("avatar"), instead of fields 
add route for the above


Mongo Db 
Mongo- Huge 
Instead of tables we have "Collections"
Instead of Rows we have "Documents"
There is no Schema in MongoDb which means if we have one document which has 4 fields we can add another with 5 fields in next insertion.

üëâCreating dbs 
use db_name

üëâCreating Collection 
inside the above db 
db.collection_name

üëâInserting doucments
db.collection_name.insertOne({name:"Ram", age:12})

üëâDisplay all the documents in the mongo Shell 
db.collection_name.find()
db.collection_name.find().toArray() //will return all the documents 

üëâUpdate document 
db.collection_name.updateOne({filter}, {$set:{whatever you want to update}})
db.collection_name.updateMany({filter}, {$set:{whatever you want to update}})
relaceOne(filter, data, options)

üëâfind documents with same property 
db.collection_name.find({hobbies:"cooking"}) //will return all the matching documents 
returns '[ ]' if found 
reurns nothing if not found 

db.collection_name.findOne({hobbies:"cooking"}) //will return only the first one or one 
returns '{ }' if found 
returns 'null' if not found 

üëâcreating documents 
insertOne(data, options)
insertMany(data, options) 
db.collection_name.insertMany([ {}, {}, {} ]) //always give them inside an array 

üëâdelete 
deleteOne(filter, options)
deleteMany(filter, options)
db.collection_name.deleteMany({}) //deletes everything from collection 

üëâcount 
db.collection_name.find({hobbies:"cooking"}).count() 
db.collection_name.find({hobbies:"cooking"}).limit(2) 

üëâgetting specific values from collection 
db.collection_name.find({}, {value:1, value:0}) 

üëâDelete Db in mongoDb 
db.dropDatabase()
db.collection_name.drop()

üëâ$lookup 
When we use $lookup MongoDB looks at left collection (the one you start from) and matches them in the right collection.
if it finds a match it goes inside array , if it does not then also it is kept inside empty array.
This is because it is left join.  